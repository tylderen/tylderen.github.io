---
layout: post
title: 数据库性能优化(-)
description: 合适的索引，合理的表结构是基础
category: blog
---

数据库在业务系统里面的重要性是不言而喻的。
然而随着系统的复杂性提高，在数据库中存放的数据越来越多，数据表以及它们之间的耦合也越来越多，查询次数以及查询的复杂度也相应提高，这个时候，大多数情况下，数据库都会成为系统的瓶颈，造成系统整体的响应速度越来越慢。

所以，数据库的性能优化就显得非常必要。
说白了，就是要想办法从数据库里面读的更快，往里面写得更快。

这里总结了一些我感觉比较重要的方面：

>* 建立合适的索引
>* 限制表的大小
>* 优化查询语句
>* 读写分离

###建立合适的索引

建立合适的索引是优化数据库查询时间（读操作）的最重要的办法之一。
索引是为查询而生的。
索引是一个特定的数据结构，使得你的数据更容易查找。

现在主流的关系数据库索引使用的数据结构默认都会是 `BTree`。
那么为什么会使用`BTree`而不是其他的数据结构呢？

这篇文章写的非常到位：

[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

(注意：不光是`MySQL`，其原理适用于所有的关系数据库。)

总结一下，就是：

>* 索引本身也可能很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘`I/O`消耗，相对于内存存取，`I/O`存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘`I/O`操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘`I/O`的存取次数。而`BTree`的独特结构完美适配了以上要求，能够最大限度的减少磁盘`I/O`的次数，从而花费较少的时间和资源完成查询任务。

所以，查询的时候，如果能够使用索引，就可以避免全表扫描，大大减少查询的时间。
例如，SQL查询语句，`where`和`join`中用到的所有字段都应该提前加好索引。

### 限制表的大小

先考虑一下表的结构。表是由行和列组成。
所以表的增长存在这两个方向上。从行的角度来说，刚开始可能也就几千行，这时候查询是没啥问题的，随着数据的插入，表可以变得很长，一旦到达几千万甚至上亿条数据，即使使用了索引，查询速度也会慢下来。这个时候就要考虑水平分表。比如，可以根据时间来分，每一个月一张表等等；
也有可能会有很多列，这就涉及到表的结构设计。这个时候需要拆分字段出来而不是统统放到一张表里。

###优化查询语句

上面两条关注的是数据库本身的一些设定，包括建索引和优化表的结构。另一方面，也要考虑查询语句的设计。
比如，很多人都会告诉你`NULL`值不参与建索引的过程。也就是说，不支持对`NULL`建索引。如果查询的`where`语句写成`where something is NULL`或者是`where something is NOT NULL`时，数据库就不得不去全表扫描从而拖慢查询速度。
不过，`Postgresql`  从`8.3`开始支持对`NULL`进行索引，也就是说不用担心这个问题了。
待续......

